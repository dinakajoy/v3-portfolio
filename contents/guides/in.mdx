---
title: "GraphQL API with Apollo Server, Express.js, and Database Integration"
description: "A step-by-step guide to building a GraphQL API with Apollo Server, Express.js, MongoDB/PostgreSQL, Mutations, RBAC, Authorization, and Redis Caching."
---

import { CodeBlock } from 'react-code-blocks';

# **GraphQL API with Apollo Server, Express.js, and Database Integration**

## **1. Project Setup**
### **Install Dependencies**
```sh
mkdir graphql-api && cd graphql-api
npm init -y
npm install express graphql apollo-server-express mongoose pg pg-promise bcrypt jsonwebtoken dotenv cors redis ioredis
```

### **Setup Environment Variables**
Create a `.env` file:
```env
PORT=4000
MONGO_URI=mongodb://localhost:27017/graphqlDB
JWT_SECRET=supersecretkey
REDIS_URL=redis://localhost:6379
```

## **2. Setting Up Apollo Server**
Create `index.js`:
```javascript
require('dotenv').config();
const express = require('express');
const { ApolloServer } = require('apollo-server-express');
const mongoose = require('mongoose');
const Redis = require('ioredis');
const { typeDefs } = require('./schema');
const { resolvers } = require('./resolvers');
const { UsersAPI } = require('./datasources/UsersAPI');
const { authenticate } = require('./auth');

const redis = new Redis(process.env.REDIS_URL);

async function startServer() {
  const app = express();
  app.use(express.json());

  await mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true });
  console.log('Connected to MongoDB');

  const server = new ApolloServer({
    typeDefs,
    resolvers,
    context: ({ req }) => authenticate(req),
    dataSources: () => ({
      usersAPI: new UsersAPI(),
      redis,
    }),
  });

  await server.start();
  server.applyMiddleware({ app });

  app.listen(process.env.PORT, () => {
    console.log(`ðŸš€ Server ready at http://localhost:${process.env.PORT}/graphql`);
  });
}

startServer();
```

## **3. Implement Authorization Rules (Admin-Only Access)**
Modify `auth.js`:
```javascript
const jwt = require('jsonwebtoken');

const authenticate = (req) => {
  const token = req.headers.authorization || '';
  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    return { user };
  } catch (error) {
    return {};
  }
};

const authorizeAdmin = (user) => {
  if (!user || user.role !== 'ADMIN') {
    throw new Error('Access denied. Admins only!');
  }
};

module.exports = { authenticate, authorizeAdmin };
```

Modify `resolvers.js` to restrict certain actions:
```javascript
const { authorizeAdmin } = require('./auth');

const resolvers = {
  Query: {
    users: async (_, __, { user }) => {
      authorizeAdmin(user);
      return await User.find();
    },
  },
  
  Mutation: {
    deleteUser: async (_, { id }, { user }) => {
      authorizeAdmin(user);
      return await User.findByIdAndDelete(id);
    },
  },
};

module.exports = { resolvers };
```

## **4. Integrate Redis Caching**
Modify `resolvers.js` to cache results:
```javascript
const resolvers = {
  Query: {
    users: async (_, __, { user, redis }) => {
      authorizeAdmin(user);
      const cacheKey = 'users_cache';
      const cachedUsers = await redis.get(cacheKey);
      if (cachedUsers) {
        return JSON.parse(cachedUsers);
      }
      const users = await User.find();
      await redis.set(cacheKey, JSON.stringify(users), 'EX', 3600); // Cache for 1 hour
      return users;
    },
  },
};

module.exports = { resolvers };
``
